\section{How to Make Benchmarks for the Value of Blame} \label{sec:mutate}

Given the comparable implementations of the three gradual typing systems,
the next step for applying our method is to obtain a set of fully
typed benchmarks that each comes with a single impedance mismatch between
its type specifications and its code. As we briefly discuss in
section~\ref{sec:challenges}, we derive such ill-typed benchmarks with
mutation analysis from well-typed programs.  





\begin{figure}
\begin{tabular}{p{1.5cm} | p{10cm} }
  {\bf  name} & {\bf description (author)}  \\

\hline

acquire & Board game simulation (M. Felleisen)  \\%[1em]


\hline
  gregor & Utilities for calendar dates (J. Zeppieri) \\%[1em]


\hline
kcfa & Functional implementation of 2CFA for the lambda calculus (M. Might) \\%[1em]


\hline
quadT & Converter from S-expresion source code to PDF format (M. Butterick)\\%[1em]
    
\hline
quadU & Converter from S-expresion source code to PDF format  (B. Greenman) \\%[1em]

\hline
snake & Functional implementation of the  Snake video game (D. Van Horn) \\%[1em]

\hline
suffixtree & Algorithm for common longest subsequences between strings. (D. Yoo) \\%[1em]

\hline
synth & Converter of description of notes and drum beats to WAV format (V. St-Amour \& N. Toronto) \\%[1em]

\hline
take5 & Card game simulator (M.Felleisen)  \\%[1em]

\hline
tetris & Functional implementation of Tetris (D. Van Horn) \\%[1em]


\end{tabular}
  \caption{Benchmarks summary.}
  \label{table:benchmark-descriptions}
\end{figure}


\begin{figure}
  \begin{tabular}{p{2cm} | p{5cm}  | p{5.5cm} }
    {\bf operator} & {\bf description} & {\bf example} \\

\hline
arithmetic 
& Swap an arithmetic operator with another one of the same (or greater)
    arity and a possibly different result type. 
    & \texttt{+} $\rightarrow$ \texttt{-} \\
\hline    

boolean 
& Swap \texttt{and} and \texttt{or}. Due to Racket's truthiness it
    possibly changes the type of the operation's result. 
& \texttt{and} $\rightarrow$ \texttt{or} \\

\hline 
constant
& Swap a literal constant with another of the same value but different type.
& \texttt{5.6} $\rightarrow$ \texttt{5.6+0.0i} \\
\hline 
deletion
    & Deletes the result expression of a \texttt{begin} or \texttt{begin0}
    sequence.
    & \texttt{(begin x y z)} $\rightarrow$ \texttt{(begin x y)} \\
\hline     
list
    & Swap \texttt{car} and \texttt{cdr}.
    & \texttt{car} $\rightarrow$ \texttt{cdr} \\
 \hline    
class:public
    & Make a public method private and vice versa.
    & 
    \begin{tabular}[t]{@{}l}
      \texttt{(class object\%}\\
        \texttt{\,\,(define/public (m x) x))}\\
       \rightarrow\\ 
      \texttt{(class object\%}\\
        \texttt{\,\,(define/private (m x) x))}\\
    \end{tabular}\\
\hline 

class:super
    & Remove \texttt{super-new} calls from class definitions.
    &  \begin{tabular}[t]{@{}l}
      \texttt{(class object\% (super-new))}\\
       \rightarrow\\ 
      \texttt{(class object\% (void))}\\
    \end{tabular}\\
\hline 

conditional
    & Negate conditional test expressions.
    &  \begin{tabular}[t]{@{}l}
      \texttt{(cond [(= x 0) 42] ...)}\\ 
       \rightarrow\\ 
      \texttt{(cond [(not (= x 0)) 42] ...)}
    \end{tabular}\\
\hline 

class:parent
    & Replace the parent of classes with \texttt{object\%}.
    &  \begin{tabular}[t]{@{}l}
     \texttt{(class foo\% ...)}\\
       \rightarrow\\ 
      \texttt{(class object\% ...)}\\
    \end{tabular}\\
\hline     

class:init
  & Swap default values of class fields.
   &  \begin{tabular}[t]{@{}l}
     \texttt{(class object\%}\\
     \texttt{\,\,(field [a 5] [b "hello"]))}\\
       \rightarrow\\ 
      \texttt{(class object\%}\\
     \texttt{\,\,(field [a "hello"] [b 5]))}\\
    \end{tabular}\\
\hline 

position
 & Swap the position of subexpressions.
  &  \begin{tabular}[t]{@{}l}
     \texttt{(f a 42 "b" 0)}\\
       \rightarrow\\ 
      \texttt{(f a 42 0 "b")}
    \end{tabular}\\
\hline 

class:method
 & Add an extra trivial public method to a class.
 &  \begin{tabular}[t]{@{}l}
   \texttt{(class object\%  ...)}\\
       \rightarrow\\ 
     \texttt{(class object\%}\\
     \texttt{\,\,(define/public (extra x) x)}\\
     \texttt{\,\,...)}
    \end{tabular}\\
\hline 

id
 & Swaps a use of a top-level identifier defined with with another defined
 in the same module.
 &\texttt{(f ...)} \rightarrow \texttt{(g ...)}
  
   

\end{tabular}
  \caption{Summary of code mutation operators.}
  \label{table:mutation-ops}
\end{figure}


