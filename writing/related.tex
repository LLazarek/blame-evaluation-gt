%% -----------------------------------------------------------------------------

At a philosophical level, \citet{lksfd-popl-2020} present the first empirical
analysis {\em without\/} involving humans in this general area.  While they do
not spell out the notion of the rational programmer, they present many of the
basic ingredients. At a technical level, the two pieces of work differ in many
ways.  First the experiment presented here involves three different modes of
gradual typing, theirs a single notion of contract checking.  Second, this paper
also contributes the idea of creating three comparable rational programmers,
with several modes. Hence it can answer whether blame adds value to a gradual
type system and which gradual type system it benefits the most, while theirs
establishes only a systematic relation between blame for contracts and
behavioral bugs. Finally, this paper also contributes type-level mutators. As
explained in section~\ref{sec:mutate}, almost none of~\citet{lksfd-popl-2020}'s
mutators is useful in the context of gradual typing.

The literature on gradual typing presents many semantics beyond the three used
here and three additional blame strategies.  Pyret (pyret.org) assigns fixed-size
data types the Natural semantics and functions a Transient semantics. The
Forgetful~\citep{cl-icfp-2017} and the Amnesic~\citep{gfd-oopsla-2019} semantics
are similar to Transient but use wrappers instead of in-lined checks.
Nom~\citep{mt-oopsla-2017} and other \emph{concrete\/}
semantics~\citep{wnlov-popl-2010, rsfbv-popl-2015, rzv-ecoop-2015,
rat-oopsla-2017} assume that every value comes with a type tag and use tag
checks to supervise the interactions between typed and untyped code.  The semantics derived with the Abstracting
Gradual Typing technique~\citep{gct-popl-2016} are variants of Natural.
The Monotonic semantics~\citep{svctg-esop-2015, rsfbv-popl-2015, sfrbcsb-popl-2014, kas-pldi-2019} 
differs from Natural in the treatment of mutable data. It 
associates every heap location with a type and permits only updates that 
do not make the type less precise.  
Among these semantics, only Amnesic, Nom, and Monotonic present interesting blame
strategies.  The experiment excludes the first because it is 
merely a theoretical construction, the second because it imposes severe restrictions on
programmers, and the third because it requires a re-engineering of the Racket runtime. 
