%% -----------------------------------------------------------------------------

A type-level mutation is {\em interesting\/} (1) if, upon removal of the type
annotations, running the program raises a run-time error, (2) whose stack trace
contains source locations from at least three modules, and (3) if this happens
in all of the to-be-evaluated semantics. An interesting mutation represents a
{\em debugging scenario\/} that supplies the rational programmer with
information.

Let us consider the three conditions in order:
\begin{enumerate}

\item By definition, an impedance mismatch is a class between type ascription of
one module to another module's exports. Hence, type checking fails for an
interesting mutant module, and removing the types from this mutant module
creates an impedance mismatch between it and the modules that import it,
directly or indirectly. This impedance mismatch is of interest if, and only if,
running the program leads to an exception---otherwise it goes unobserved and
cannot be debugged.

\item If the evaluation o mutant module immediately raises an exception because
of the changes, there is no work for the rational programmer. Indeed, if the
stack trace contains source pointers to two modules, the scenario is still
uninteresting. Every ordinary benchmark program comes with a {\tt main} module
that acts as a driver, whose source is guaranteed to be included in the stack
trace.  Hence, the definition of interesting mutation insists on the presence of
three different modules in the stack trace. This guarantees that the debugging
scenario demands a sufficiently sophisticated effort, due to the interaction
between the buggy module with its context.  In these cases, the rational
programmer must examine at least modules to locate the source of the faulty
interaction.

\item The goal of a comparative evaluation is to give the rational programmer a
chance to debug the same scenario using different pieces of information.  In the
case of gradual typing semantics, a meta-theorem due to Greenman and
Felleisen~\cite{gf-icfp-2018} says that if a program raises an exception under
Erasure, it also errors under all other semantics.  Hence, a comparison of blame
information insists that a debugging scenario {\em raises a run-time exception
under Erasure\/}.

{\bf Note} While this choice favors Erasure over Transient and Natural and, for
the same reason, Transient over Natural, some form of bias towards one or the
other semantics is unavoidable. Tipping the scales in favor of the theoretically
weakest semantics yields the most stable results. See
section~\ref{sec:discussion} for some further discussion of this choice.

\end{enumerate}

%\begin{figure*}
%  \centering
%  \includegraphics[scale=0.35]{./plots/mutant-breakdown}
%  \caption{Interesting debugging scenarios produced by our mutators. Counts are cut off at 50.}
%  \label{fig:mutant-breakdown}
%\end{figure*}

