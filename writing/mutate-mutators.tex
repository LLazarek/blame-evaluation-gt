% -----------------------------------------------------------------------------

A {\it mutator\/} performs a localized syntactic change to a code base. The
result is a {\em mutant\/}.

For the evaluation of a blame strategy, mutators must produce type-level
mistakes that the run-time checks of gradual typing systems or the safety
checks of the underlying language can detect. Once detected, the rational
programmer should be able to locate the mistake by gradually adding types to
blamed modules.

Figure~\ref{table:mutation-ops} describes the 16 mutators used for the
experiment.  For each mutator, the figure provides a short description and
an example mutation.  Most are self-explanatory.  The first twelve apply
to most gradually typed languages, including those with classes.  The last
four target distinguishing features of Typed Racket.  Specifically, {\tt
arithmetic} may replace a {\tt +} with a {\tt -} in an attempt to change
the type of the result of the arithmetic operation. In Typed Racket, {\tt
+}'s result is a {\tt Positive-Integer} when all arguments are positive
integers~\cite{stathff-padl-12}. However, the result of {\tt -} is {\tt
Integer}. In the same spirit, the {\tt boolean} mutator aims to take
advantage of Typed Racket faithfulness to Racket's ``falsiness.'' Finally,
{\tt negate-cond} and {\tt force-cond} attempt to confuse occurrence
typing.

For the design of these mutators, the starting point is the mutators of
~\citet{lksfd-popl-2020} which in turn are borrowed from   the vast
literature on mutation testing~\cite{jia2011analysis}. However, only 2
of the previous mutators transfer as is to the context of this study, 1 is
entirely ineffective and 5 need significant modifications. For the
latter  the authors relied on their decades-long experience of making type-level mistakes in Typed
Racket, some of which take a non-trivial effort to debug.  In more detail,
the relational mutator of ~\citet{lksfd-popl-2020} does not lead to
type-level errors that Typed Racket's type system can detect, so it has
been eliminated. Similarly, the original arithmetic mutator does not
reliably lead to type errors, so it has been adapted to only make operator
swaps that can affect the type of the result. For example, changing a `/`
to `*` does not affect the type of an expression, but changing `*` to `/`
may s division by zero is detectable by Typed Racket's type system. 
In addition to careful tweaking of previous mutators, the final
set of mutators comes with 9 new ones that collectively
produce a sufficiently large and diverse set of type-level mistakes. 
For example, unlike the traditional subexpression swap mutator, 
the {\tt -id} family of mutators apply in different
contexts and utilize different pieces of non-local information about the
identifiers in a program. 


As a final remark, the 16 selected mutators not only produce  type-level
mistakes  reliably but also interesting debugging scenarios. Most
mutators,  including variants of the ones
~\citet{w:good-types-mutation} propose, some times achieve the first but 
rarely the second. 
 For example,  adding a new public method to
a class surprisingly leads to mutants that either terminate 
successfully or to mutants that fail 
 immediately during the evaluation of the mutated class.  
 In contrast, the seemingly similar mutator that turns a private method into    
 a public one affects inheritance and leads to subtle bugs.  
Hence, due to the elusive nature of mutators, it is imperative to define
precisely what makes a debugging scenario interesting. 
 


