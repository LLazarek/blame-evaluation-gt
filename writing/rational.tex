\section{How to Simulate the Rational Programmer} 

Code migration is the raison d'\^etre of Typed Racket, which is the community
uses ``migratory typing'' instead of gradual typing. Roughly speaking a
programmer uses a gradually typed language to incrementally add types to a code
base. From this perspective, a code base consists of some number of components,
say modules, and a programmer converts a component at a time from its untyped
state to a typed one. 

Based on this idea, a metric for migratory paths is a concise way to measure a
rational programmer. The components of the program create a \emph{configuration
space}, like the one introduced by~\citet{tfgnvf-popl-2016}. This space consists
of variants of the program, dubbed \emph{configurations}, that differ in their
type specifications. In the setting of migratory typing,\footnote{The method can
be adapted to so-called true gradual typing systems~\cite{svcb-snapl-2015} in a
straightforward manner.} each configuration differs from another in the subset
of typed components. Formally, a program $\system$ is a set of components
$\set{\component}$, and a configuration $\conf$ is a subset of
$\set{\component}$ . These configurations of $\system$ are ordered by the subset
relation and thus form a lattice $\lattice{\system}$ with $2^{\size{\system}}$
elements.  The bottom configuration of $\lattice{\system}$ is always $\emptyset$
and the top element is $\system$ itself. In between are all the mixed-type
configurations.

With these definitions, the actions of the rational programmer map to an
ascending chain---dubbed a \emph{trail}---in $\lattice{\system}$.  The starting
configuration $\conf_0$ of a trail---also referred to the \emph{root} (of the
trail)---is the configuration that the programmer attempts to debug. Any other
configuration $\conf_{i+1}$ in the trail differs from its predecessor
$\conf_{i}$ in that the untyped component that $\conf_i$ blames under the
various semantics, dubbed $\blame{\system, \conf_i}$, becomes typed in
$\conf_{i+1}$.\footnote{Blame can result either directly from a run time type
check or, in the absence of blame, from an exception that we track back to the
component that causes it with the help of the stack trace.}

The next three subsections specialize the idea to the various semantics of
gradual typing. Once this machinery is in place, we use the fourth subsection to
state the precise experimental research questions that correspond to the
high-level question on the first page. The final subsection explains how the
rational programmer's effort is measured. 


%% -----------------------------------------------------------------------------
\subsection{Modes of Natural Type Programming} \label{sub:natural}

Putting these pieces together:

\begin{quote}
\it 
A natural blame trail
is a sequence of configurations $\conf_0,...\conf_n$ of a program
$\system$ where for all $0 \leq i \leq n - 1$, $\conf_i \subset \conf_{i+1}$ and
$\conf_{i+1} \setminus \conf_i = \{\blame{\system, \conf_i}\}$.
\end{quote}

To define capture whether blame helps rational
programmers in their search for bugs, we define when a trail is successful:
\begin{quote}
\it 
A trail $\conf_0,...\conf_n$ in a lattice $\lattice{\system}$ is
\emph{successful}  iff its last configuration $\conf_n$ does not type check.
  \end{quote}
  In juxtaposition:
\begin{quote}
\it 
A trail $\conf_0,...\conf_n$ in a lattice $\lattice{\system}$ is
\emph{failing}  iff $\conf_n$ type checks and $\blame{\system,\conf_n}$ is
undefined, meaning $\conf_n$ does not result in blame. 
 \end{quote}
That is failing trails are those that we cannot extend
further following blame and have not reached a configuration that reveals
the bug at
compile time.

 We can now give a precise definition of what it
means for blame to help the rational programmer:
\begin{quote}
\it
  Natural blame is useful for a program $\system$ iff 
  $\lattice{\system}$ contains no failing natural blame trails.
\end{quote}


However, this definition does not give a full picture of how much blame helps the
natural rational programmer. In particular,  a $\lattice{\system}$
may contain no failing natural blame trails because
of the run time type checks natural performs rather than blame, or even as a result
of pure chance. To account for these possibilities, we define two extra
modes for the rational programmer. In the first, the natural programmer
ignores blame and instead decides what component to type next based on
information from the stack trace of the failed runtime type check of a
configuration.  This exception mode of the rational programmer corresponds to \emph{natural
exception trails}:
\begin{quote}
\it 
A natural exception trail
is a sequence of configurations $\conf_0,...\conf_n$ of a program
$\system$ where for all $0 \leq i \leq n - 1$, $\conf_i \subset \conf_{i+1}$ and
$\conf_{i+1} \setminus \conf_i = \{\error{\system, \conf_i}\}$
  where $\error{\system, \conf}$ denotes the component that triggers a
an exception of the underlying language.
\end{quote}

In the second mode, the natural programmer
ignores any kind of information related to the type error and randomly
picks which component to type next:
\begin{quote}
\it 
A natural random trail
is a sequence of configurations $\conf_0,...\conf_n$ of a program
$\system$ where for all $0 \leq i \leq n - 1$, $\conf_i \subset \conf_{i+1}$ and
$\conf_{i+1} \setminus \conf_i = \{\random{\system, \conf_i}\}$
where $\random{\system, \conf}$ denotes a randomly selected component of $\system$
that is not in $\conf_i$.
\end{quote}
\noindent

With exception and random trails, we can finaly define the value that blame
adds to the natural semantics: 
\begin{quote}
\it
  Blame adds value to natural for a program $\system$ iff 
  no natural blame trails in  $\lattice{\system}$ are failing while 
 there exist at least one vanilla and one random natural trail that is
  failing.
\end{quote}

 

\noindent
{\bf Experimental Process.}~Given a set of faulty benchmarks such as the
ones from section~\ref{sec:mutate}, it is straightforward to turn the
above definition into the an experimental question for natural Typed Racket. 
Specifically, for
each benchmark we first construct its configuration lattice. Then, we
determine the configurations of the lattice that detect the fault in the
program. This can happen either because a runtime type check fails or
because Typed Racket's type checker rejects the configuration. In either
case,  each of these configurations is the root of a natural blame trail
in the configuration lattice of the benchmark. We ask whether
\emph{no such natural blame trail is failing}.  Furthermore  we also
examine whether \emph{there are failing exception and random trails that start
from the same roots}.  To answer the questions for a
benchmark, we simply start from our set of roots and extend each
trail according to the corresponding mode of the rational programmer
until no configurations can be added to the trail\footnote{All trails
reach that point since the lattices are finite.}. Finally we check if the
last configuration of each trail type checks or not. If it does the trail
is successful, otherwise it is failing. 

%% -----------------------------------------------------------------------------
\subsection{Modes of Optional Type Programming} \label{sub:transient}

The case of erasure semantics is analogous to the third mode of natural.  Since
gradually typed languages with erasure semantics do not come with blame
assignment, a rational programmer can only hope that the underlying safety
checks and their stack traces are helpful.  Thus, in the same veub as for
natural we ask whether the configuration lattice of a given program contains
only successful erasure exception trail and at least one failing erasure random
trail. 

%% -----------------------------------------------------------------------------
\subsection{Modes of Transient Type Programming} \label{sub:transient}

Adapting the simulation of rational programmer to transient
requires taking into account the distinguishing
features of each semantics. As we discuss in section~\ref{sec:landscape}, 
transient blames a set of components in contrast to natural's
single-component blame. 

For transient, we 
need two transient-specific modes for the rational
programmer instead of natural's blame mode. Specifically, in the first mode, the rational programmer types
all blamed components.  In the second mode, the rational programmer types
the component that is added to the blame set first --- and thus can 
detect an impedance mismatch earlier in the evaluation of a program. 
As before, the two modes give
rise to two different notions of trail:
\begin{quote}
\it 
A  transient all blame trail
is a sequence of configurations $\conf_0,...\conf_n$ of a program
$\system$ where for all $0 \leq i \leq n - 1$, $\conf_i \subset \conf_{i+1}$ and
~$\conf_{i+1} \setminus \conf_i \in \mblame{\system, \conf_i}$
where $\mblame{\system, \conf}$ denotes the set of components that $\conf$
blames under transient semantics; 
\end{quote}
\noindent
and
\begin{quote}
\it 
A transient firstborn  trail
is a sequence of configurations $\conf_0,...\conf_n$ of a program
$\system$ where for all $0 \leq i \leq n - 1$, $\conf_i \subset \conf_{i+1}$ and
  $\conf_{i+1} \setminus \conf_i = \first{\mblame{\system, \conf_i}}$
  where $\first{\mblame{\system, \conf}}$ denotes the first component 
  the transient semantics add to the blame set for $\conf$.
\end{quote}


\noindent
{\bf Experimental Process.} Similar to the experiment for natural, we can
test whether blame adds value to transient. However, we must ask two
separate questions about blame; one for each mode of the transient
rational programmer. Specifically, we have two derivative questions: (i)
does blame add value to transient if the rational programmer focuses on all
blamed components of a configuration and (ii) does blame adds value to
transient if the rational programmer focuses on the earliest entry in a
configuration's blame set? The two questions boil down to using 
transient all blame trails and transient
firstborn trails respectively and performing twice the same experiment as that
for natural blame. 

%% -----------------------------------------------------------------------------
\subsection{Questions}

In sum, our experiment examines four questions for each benchmark:
\begin{itemize}
\item[$Q_1$] Does natural blame add value to natural?

\item[$Q_2$] Does transient all blame add value to transient?

\item[$Q_3$] Does transient firstborn blame add value to transient?

\item[$Q_*$] Do exceptions add value? For any of the systems? 
\end{itemize}

Table~\ref{fig:experiment-outline} summarizes how each question relates to
different trails/modes of the rational programmer. For example experimental
question $Q_1$ asks whether blame adds value to transient and our experiment
uses the natural blame, exception and random trails to answer it.

\begin{figure}
\center
{\begin{tabular}[ht]{l|c|c|c}
%% ---------------------------------------------------------------------------------------------------------------
                        & {\bf Natural}        & {\bf Transient}          & {\bf Erasure} \\ \hline 
%% ---------------------------------------------------------------------------------------------------------------
{\bf Blame}             &       $Q_1$          &                          &               \\
{\bf All blame}         &                      &     $Q_2$                &               \\
{\bf Firstborn blame}   &                      &     $Q_3$                &               \\
{\bf Exception}         &       $Q_1$/$Q_*$    &     $Q_2$/$Q_3$/$Q_*$    &      $Q_*$    \\
{\bf Random}            &       $Q_1$/$Q_*$    &     $Q_2$/$Q_3$/$Q_*$    &      $Q_*$    \\
\end{tabular}}
  \caption{ Experimental questions and rational programmer modes.}
  \label{fig:experiment-outline}
\end{figure}

%% -----------------------------------------------------------------------------

\subsection{Programmer Effort}

In addition to the value of blame, trails permit us to examine the effort a
rational programmer spends to locate a bug.  For instance, the length of a
successful natural blame trail tells us how many components the programmer has
to type before reaching the faulty component. This idea also applies to all
other modes of the rational programmer. The most interesting case is that for
transient all blame trails.  In detail, given a successful transient all blame
trail $\conf_0, ...., \conf_n$ in a configuration lattice $\lattice{\system}$,
the effort of the rational programmer is the number of distinct configurations
in the all blame trails with root $\conf_n$ and length $n$ in
$\lattice{\system}$. Our experiment utilizes this notion of effort to analyze
burden on the rational programmer for finding a bug when the answer to one of
the experimental questions from above is positive for a benchmark.
