\section{What We Learned}

\begin{itemize}
  \item Interesting discoveries...?

  \item Comparison of existing GT systems represented in our study.  
    Natural is here, transient is here, erasure is here, and they
        compare as...

      \item Threats to validity:
        \begin{itemize}
          \item Racket stack traces
          \item Mutant sampling
          \item Blame trails do not necessarily capture all aspects of error reporting
          \item Transient blame adaptations
          \item More?

	  \item is the rational programmer rational? 

        \end{itemize}
\end{itemize}        


Like {\em homo economicus\/}, which decouples the actual behavior of a
participant in an economy for the sake of mathematical modeling, the
model of a rational programmer decouples the actual debugging behavior
of a software developer for the sake of a systematic, large-scale
analysis. This decoupling comes advantages and disadvantages. In the
economic realm, mathematical models have provided some predictive
insights into the market's behavior; but as behavioral economics has
shown more recently, the mathematical abstraction of a rational actor
makes predictions also quite unreliable in some situations.
\footnote{It has also misled economists to focus on just the
mathematics, though this problem is not relevant here.}  Just like an
ordinary consumer or producer, an actual software developer is
unlikely to stick to the exact strategy proposed here. When this
happens, the predicted benefits of blame assignment may not
materialize. Indeed, our own personal experience suggests such
deviations, and it also suggests that deviating is a mistake. To make
a true judgment of the usefulness of the rational-programmer idea, the
community will need a lot more experience with this form of evaluation
and relating the evaluation to the behavior of working programmers. 


