%% -----------------------------------------------------------------------------
\def\fname#1#2{$\underline{\hbox to #2in{#1}}$\\[-2ex]}

\begin{figure*}[hbt]\footnotesize
  \vspace{-1mm}

\begin{minipage}[t]{2.2in}
\begin{alltt}\fname{untyped/pack-lib}{1.8}
(provide pack _ _ _)

_ _ _  dependencies     _ _ _
_ _ _  and definitions  _ _ _

(define (pack d)
  ;; process JSON data and 
  ;; package it in a dictionary
  ;; (association list)
  (make-hash _ _ _) ;; BUG!)


\end{alltt}
\end{minipage}\begin{minipage}[t]{2.2in}
\begin{alltt}\fname{typed/pack-lib}{1.7}
(provide typed-pack)

(require/typed pack-lib
  [pack 
  (-> JSON 
      (Listof 
       (Pairof Symbol String)))])

(define typed-pack pack) 
\end{alltt}
\smallskip
\begin{alltt}\fname{typed/crypto-pack-lib}{1.7}
(provide crypto-pack) 

(require/typed pack-lib
 [pack 
  (-> JSON 
      (Listof 
       (Pairof Symbol String)))])

(define (crypto-pack [d : JSON])
  (pack (encrypt d _ _ _)))

 \end{alltt}
\end{minipage}\begin{minipage}[t]{2.2in}
\begin{alltt}\fname{untyped/client}{1.65}
(require json 
         typed/pack-lib
           typed/crypto-pack-lib)

_ _ _  other dependencies  _ _ _
_ _ _  and definitions     _ _ _
          
;; read data from files, pack 
;; and share securely 

(define public-data 
  (typed-pack 
   (read-json 
    "public-records")))

(define secret-data 
  (crypto-pack 
   (read-json 
    "medical-records")))
 
 _ _ _ rest of client _ _ _
\end{alltt}\end{minipage}

   \caption{One mix-typed program, three interpretations} \label{fig:example}

  \vspace{-1mm}
\end{figure*}
%% -----------------------------------------------------------------------------

The program sketch in figure~\ref{fig:example} demonstrates the
differences between Natural, Transient and Erasure using Typed Racket
syntax.  The modules on the left and right are untyped while the two
in the middle are typed.

The \texttt{untyped/pack-lib} module (left) provides, among others, a function
\texttt{pack} that consumes JSON data and packages it in a dictionary. However,
by mistake \texttt{pack} returns a hash table instead of the association list
its documentation promises.  The \texttt{client} module (right) uses
\texttt{pack} indirectly to package public and sensitive data it reads from the
filesystem. It does so through two different intermediary typed modules
(center). The first, {\tt typed/pack-lib}, imports \texttt{pack} and re-exports
it as \texttt{typed-pack} asserting that it is a function that consumes {\tt
JSON} and returns a list associating {\tt Symbol}s with {\tt String}s. The
second typed module, {\tt typed/crypto-pack-lib}, also imports \texttt{pack} and
assumes for it the same type as {\tt typed/pack-lib}. Instead of exporting it,
it uses the function in the exported {\tt crypto-pack} function, which encrypts
its input before passing it to \texttt{pack}.

Under the {\it Natural\/} semantics~\cite{tf-popl-2008,tfffgksst-snapl-2017},
functions imported into and exported from typed modules are wrapped in proxies
that enforce the static type discipline with run-time checks and track
responsibilities. Thus, when \texttt{pack} is imported into a typed module, the
run-time system checks that it is a function and wraps it in a protective proxy,
which in turn, enforces the type of the function with run-time checks.  In
essence, this check protects typed modules when they call an untyped function
because it may not produce the promised kind of value, as is the case here with
{\tt pack} from {\tt untyped/pack-lib}. Analogously the run-time system wraps
exported functions such as {\tt crypto-pack} of a typed modules in a proxy that
checks its arguments.  This check protects functions exported from type modules
against applications in untyped code that supply the wrong kind of argument
value.

As this analysis implies, if the return-type check fails, the problem is with
the untyped module that supplied an incorrect function, here {\tt
untyped/pack-lib}. If the argument-type check fails, responsibility lies with
{\tt client}. Due to the proxies wrapped around functions, Natural can easily
track the responsible party for each check. Thus, in the example of
figure~\ref{fig:example}, as \texttt{typed-pack} returns, the return-type check
fails, and Natural blames \texttt{pack-lib}.

Under the Transient semantics~\cite{vss-popl-2017}, typed code is compiled so
that all entry points to functions check their arguments at run time and all
function calls check their return values against the expected type.
Furthermore, Transient uses \emph{shallow} checks, meaning they check only the
top constructor of a value. Since retrieving a value from within a structure (or
list, array, hash table etc.) is performed via a function call, the innards of a
complex value are checked on a piecemeal basis.

As a result, the call to \texttt{typed-pack} does not signal an error because
the call takes place in the untyped {\tt client} module, which is compiled in
the usual manner. Because {\tt pack} is called in the {\tt
typed/crypto-pack-lib} module, Transient's inlined checks make sure that the
imported \texttt{pack} is a function and that the result of its call in is a
list. This last check fails when \texttt{client} calls to {\tt crypto-pack}.

In order to pinpoint the responsible party for failed checks, Transient
maintains a map from values to the boundaries between typed/untyped modules that
they cross, plus the corresponding types. In the example, the map records that
\texttt{pack} crosses from \texttt{untyped/pack-lib} to {\tt typed/pack-lib} and
from {\tt typed/pack-lib} to {\tt client} with the type that appears in the {\tt
required/typed} forms in the example. Since the failed check corresponds to the
return type of \texttt{pack}, Transient blames the sources of the two boundary
crosses, which in this particular case is \texttt{untyped/pack-lib} for both. In
general though, Transient blames more than one party. In fact, the theoretical
work of~\citet{gfd-oopsla-2019} shows that for some programs Transient
constructs a blame set that excludes responsible parties and includes modules
irrelevant to the failing check.

Under the Erasure semantics, the compiler checks the specified types and then
discards them when it generates code. The generated code includes run-time
checks that ensure the dynamic safety of all operations as specified in the
underlying untyped language. Hence, neither the call to {\tt typed-pack} nor the
call to {\tt crypto-pack} signals an error due to the gradual type system.

When run, the program may fail with an exception if \texttt{client} tries to
inspect the elements of the list that \texttt{typed-pack} and
\texttt{crypto-pack} are supposed to produce. The information in this exception,
plus its stack trace, or may not help the programmer find the source of the
impedance mismatch between the specified return types of {\tt pack} in the two
typed modules and the actual return value of {\tt pack}.

All three systems used here are implemented on top of the common basis of
Racket. The use the Typed Racket syntax and type checker for all three
semantics. The Natural semantics is inherited as is, while the Erasure semantics
is the one of plain Racket.  The Transient system implements the design
of~\citet{vss-popl-2017}, though constructing it demands two design decisions:
which shallow checks to use and where, plus how to maintain a blame map in a
full-fledged run-time system. 

For certain types, such as {\tt String} or {\tt (Vectorof Byte)}, Transient can
realize shallow checks with the predicate from Racket.  Other types require
custom predicates; for example the type {\tt Index} of valid array indices
allows a range of positive exact integers.  Many custom predicates run in
constant time, but some, such as the one for {\tt (Union T1 ... Tn)}, run in
linear time. The key point is that no shallow check inspects beyond the top
constructor of each type.

Once the type checker has completed its work, Transient translates the source
into an alternative form and in the process inserts run-time checks. Technically
speaking, the rewriting pass wraps all elimination in applications of shallow
checks.  For example, if the variable {\tt f} has the static type {\tt (->
String String)}, the application {\tt (f x)} must be rewritten to check for a
string result because {\tt f} could be an untyped function.

The rewriting pass also inserts hooks for updating the blame map.  When a value
crosses a module boundary, such a hook records a type assumption in the blame
map.  The in-lined checks for elimination forms extend the blame map with
further information. For instance, the check of the result of {\tt (f x)} adds
an entry to the blame map that records the expected type of the result as the
return type of the type of {\tt f}.  If a Transient check ever fails, the
run-time checking system of Transient Racket walks over the information in the
blame map and reports a sequence of blamed components.

%% MF: I have no clue what the following contributes: 

% \smallskip
% \noindent
% {\bf Note.} As the common basis for the three semantics, we choose Typed
% Racket's migratory typing. In contrast to the initial formulation of gradual
% typing~\cite{st-sfp-2006}, migratory typing does not provide support for type
% \texttt{Dyn}, components are either untyped or fully typed.
% %% MF: does it ever:
% %% and the gradual type system does not affect the compilation of untyped components. 
% Despite, these differences, Typed Racket is the most
% mature system for sound mix-typed code
% and recent theoretical work has established that
% its migratory typing offers a setting for comparing different approaches to gradual
% typing~\cite{gf-icfp-2018,gfd-oopsla-2019}.
