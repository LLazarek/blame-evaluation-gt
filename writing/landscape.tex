%% -----------------------------------------------------------------------------

The three blame strategies rely on three different ways of catching problems
with types at run-time: {\em Natural\/}, {\em Transient\/}, and {\em
Erasure\/}. This self-contained section summarizes these options with one illustrative example
using Racket syntax. The informed reader may wish to merely scan it.

Consider the program sketch in figure~\ref{fig:example}. Each box represents a
module: the top bar lists the name and whether it is using typed (\typecolor) or
untyped (\dyncolor) syntax.
\begin{description}

\item[\texttt{pack-lib}] (at the top right) represents a library that provides,
among others, a function {\tt pack}. As the documentation says, this function
consumes JSON data and packages it in an association list (like a dictionary). By mistake, though, the
function returns a hash table instead of the association list its documentation
promises.

\item[\texttt{types}] (at the top left) is one of three modules that overlays
types onto this library. This specific modules defines types in common to the
two other typed libraries. 

\item[\texttt{typed-pack-lib}] (at the mid-level on the left), imports {\tt pack}
and re-exports it as \texttt{typed-pack} asserting that it is a function that
consumes {\tt JSON} and returns a list associating {\tt Symbol}s with {\tt
String}s. In other words, it formalizes the comments in {\tt pack-lib}.

\item[\texttt{crypto-pack-lib}] (at the bottom left) also imports \texttt{pack}
and assumes for it the same type as {\tt typed-pack-lib}. It applies the
function in the definition of the exported {\tt crypto-pack} function, which
encrypts its input before passing it to \texttt{pack}.

\item[\texttt{client}] (at the bottom right) uses {\tt pack}
indirectly. Specifically, it goes through the two intermediary typed modules to
use it. Imagine a programmer who relies on the types in the \typecolor\
modules as checked documentation but prototypes the client in an untyped manner.

\end{description}
Due to the mistake in {\tt pack-lib}, each of the three semantics assigns a
different outcome to the client module and signals different kinds of errors.

Under {\it the Natural semantics\/}, functions imported into and exported from
typed modules are wrapped in proxies that enforce the static type discipline
with run-time checks and track responsibilities~\cite{tf-popl-2008,
tfffgksst-snapl-2017}. Thus, when {\tt pack} is imported into a typed module,
the run-time system checks that it is a function and wraps it in a protective
proxy, which in turn, enforces the type of the function arguments with run-time checks.
Analogously the run-time system wraps each exported function of a typed module
(such as {\tt crypto-pack}) in a proxy that checks its arguments.  These checks
protect functions exported from typed modules against applications in untyped
code that supply the wrong kind of arguments.

As this analysis implies, if a return-type check fails, the problem is with
the untyped module that supplied an incorrect function, here {\tt pack-lib}. If
an argument-type check fails, responsibility lies with {\tt client}. Due to the
proxies wrapped around functions, Natural can easily track the responsible party
for each check. Thus, in the example of figure~\ref{fig:example}, as
\texttt{pack} returns, the return-type check fails and Natural blames
\texttt{pack-lib} for both {\tt define}s in {\tt client}.

Under {\it the Transient semantics\/}, typed code is compiled so that all entry
points to functions check their arguments at run time and all function calls
check their return values against the expected type~\cite{vss-popl-2017}.
Furthermore, Transient uses \emph{shallow} checks, meaning they inspect only the
top constructor of a value. Since retrieving a value from within a structure (or
list, array, hash table etc.) is performed via a function call, the contents of a
complex value is checked on a piecemeal basis.

As a result, the call to \texttt{typed-pack} does {\em not\/} signal an error
because it takes place in the untyped {\tt client} module, which is compiled in
the usual manner. Because {\tt pack} is called in the {\tt crypto-pack-lib}
module, Transient's inlined checks make sure that the imported
\texttt{pack} is a function and that its result is a list. This
last check fails in \texttt{client}'s call to {\tt crypto-pack}.

In order to locate the responsible party for failed checks, Transient
maintains a map from values to the boundaries between typed and untyped modules that
they cross, plus the corresponding types. In the example, the map records that
\texttt{pack} crosses from \texttt{pack-lib} to {\tt typed-pack-lib} and
from {\tt pack-lib} to {\tt crypto-pack-lib} with the type that appears in the
{\tt required/typed} forms in the example. Since the failed check corresponds to
the return type of \texttt{pack}, Transient blames the sources of the two
boundary crossings, which in this particular case is \texttt{pack-lib}. In
general though, Transient blames more than one party. In fact, the theoretical
work of~\citet{gfd-oopsla-2019} shows that for some programs Transient
constructs a blame sequence that excludes responsible parties and includes modules
irrelevant to the failing check.

Under {\it the Erasure semantics\/}, the compiler checks the specified types and
then discards them when it generates code. The generated code includes run-time
checks that ensure the dynamic safety of all operations as specified in the
underlying untyped language. Hence, neither the call to {\tt typed-pack} nor the
call to {\tt crypto-pack} signals an error due to the gradual type system. If
at some later point {\tt client} tries to inspect the elements of the lists
that \texttt{typed-pack} and {\tt crypto-pack} are supposed to produce, Racket's
safety checks signal a violation and point to some place in {\tt client}. The
information in this exception, plus its stack trace, may help the programmer
find the source of the impedance mismatch between the specified return types of
{\tt pack} in the two typed modules and the actual return value of {\tt pack}.

The following table summarizes the illustration:
%% -----------------------------------------------------------------------------
\begin{center}
  \begin{tabular}{l|ll@{}}
                        &        \multicolumn{2}{|c}{the evaluation of} \\
\relax                  & {\tt public-data}               & {\tt secret-data} in {\tt client}, \\
{under the $\cdot$ semantics yields} & & \\ \hline
%% ----------------------------------------------------------------------------------------
\qquad {\it Natural\/}   & error, blaming {\tt pack-lib}  & error, blaming {\tt pack-lib} \\
     		   	 &                                & \\
\qquad {\it Transient\/} & no error   		          & error, blaming the boundary crossings \\
      		  	 &    			          & \quad {\tt pack-lib} to {\tt typed-pack-lib} \\
               &                     & \quad {\tt pack-lib} to {\tt crypto-pack-lib} \\
\qquad {\it Erasure\/}   & no error 		          & no error \\
       	    		 &   \multicolumn{2}{|c}{but {\em Erasure} does signal an error on list access}
\end{tabular}
\end{center}
%% -----------------------------------------------------------------------------

