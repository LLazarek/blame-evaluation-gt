%% -----------------------------------------------------------------------------

The three blame strategies rely on three different ways of catching problems
with types at run-time: {\em Natural\/}, {\em Transient\/}, and {\em
Erasure\/}. This section summarizes these options with one illustrative example
using Racket syntax. The informed reader may wish to merely scan the
self-contained section.

Consider the program sketch in figure~\ref{fig:example}. Each box represents a
module: the top bar lists the name and whether it is using typed (\typecolor) or
untyped (\dyncolor) syntax:
\begin{description}

\item[\texttt{pack-lib}] (at the top right) represents a library that provides,
among others, a function {\tt pack}. As the documentation says, this function
consumes JSON data and packages it in a dictionary. by mistake, though, the
function returns a hash table instead of the association list its documentation
promises.

\item[\texttt{types}] (at the top left) is one of three modules that overlays
types onto this library. This specific modules defines types in common to the
two other typed libraries. 

\item[\texttt{typed-pack-lib}] (at the mid-level on the left), imports {\tt pack}
and re-exports it as \texttt{typed-pack} asserting that it is a function that
consumes {\tt JSON} and returns a list associating {\tt Symbol}s with {\tt
String}s. In other words, it formalizes the comments in {\tt pack-lib}.

\item[\texttt{crypto-pkac-lib}] (at the bottom left) also imports \texttt{pack}
and assumes for it the same type as {\tt typed-pack-lib}. It applies the
function in the definition of the exported {\tt crypto-pack} function, which
encrypts its input before passing it to \texttt{pack}.

\item[\texttt{client}] (at the bottom right) uses {\tt pack}
indirectly. Specifically, it goes through the two intermediary typed modules to
import them. Imagine a programmer who relies on the types in the \typecolor\
modules as checked documentation but prototypes the client in an untyped manner.

\end{description}
Each of the three semantics assigns a different outcome to the client module and
signals different kinds of errors. 

Under {\it the Natural semantics\/}, functions imported into and exported from
typed modules are wrapped in proxies that enforce the static type discipline
with run-time checks and track responsibilities~\cite{tf-popl-2008,
tfffgksst-snapl-2017}. Thus, when {\tt pack} is imported into a typed module,
the run-time system checks that it is a function and wraps it in a protective
proxy, which in turn, enforces the type of the function with run-time checks.
In essence, this check protects typed modules when they call an untyped function
because it may not produce the promised kind of value, as is the case here with
{\tt pack} from {\tt pack-lib}. Analogously the run-time system wraps exported
functions such as {\tt crypto-pack} of a typed modules in a proxy that checks
its arguments.  This check protects functions exported from type modules against
applications in untyped code that supply the wrong kind of argument value.

As this analysis implies, if the return-type check fails, the problem is with
the untyped module that supplied an incorrect function, here {\tt pack-lib}. If
the argument-type check fails, responsibility lies with {\tt client}. Due to the
proxies wrapped around functions, Natural can easily track the responsible party
for each check. Thus, in the example of figure~\ref{fig:example}, as
\texttt{typed-pack} returns, the return-type check fails, and Natural blames
\texttt{typed-pack-lib}.

Under {\it the Transient semantics\/}, typed code is compiled so that all entry
points to functions check their arguments at run time and all function calls
check their return values against the expected type~\cite{vss-popl-2017}.
Furthermore, Transient uses \emph{shallow} checks, meaning they inspect only the
top constructor of a value. Since retrieving a value from within a structure (or
list, array, hash table etc.) is performed via a function call, the innards of a
complex value are checked on a piecemeal basis.

As a result, the call to \texttt{typed-pack} does {\em not\/} signal an error
because it takes place in the untyped {\tt client} module, which is compiled in
the usual manner. Because {\tt pack} is called in the {\tt crypto-pack-lib}
module, Transient's inlined checks make sure that the imported
\texttt{pack} is a function and that the result of its call in is a list. This
last check fails when \texttt{client} calls to {\tt crypto-pack}.

In order to pinpoint the responsible party for failed checks, Transient
maintains a map from values to the boundaries between typed/untyped modules that
they cross, plus the corresponding types. In the example, the map records that
\texttt{pack} crosses from \texttt{pack-lib} to {\tt crypto-pack-lib} and
from {\tt crypto-pack-lib} to {\tt client} with the type that appears in the
{\tt required/typed} forms in the example. Since the failed check corresponds to
the return type of \texttt{pack}, Transient blames the sources of the two
boundary crossings, which in this particular case is \texttt{pack-lib}. In
general though, Transient blames more than one party. In fact, the theoretical
work of~\citet{gfd-oopsla-2019} shows that for some programs Transient
constructs a blame set that excludes responsible parties and includes modules
irrelevant to the failing check.

Under {\it the Erasure semantics\/}, the compiler checks the specified types and
then discards them when it generates code. The generated code includes run-time
checks that ensure the dynamic safety of all operations as specified in the
underlying untyped language. Hence, neither the call to {\tt typed-pack} nor the
call to {\tt crypto-pack} signals an error due to the gradual type system. When,
at some later point, {\tt client} tries to inspect the elements of the lists
that \texttt{typed-pack} and {\tt crypto-pack} are supposed to produce, Racket's
safety check signal a violation and point to some place in {\tt client}. The
information in this exception, plus its stack trace, may help the programmer
find the source of the impedance mismatch between the specified return types of
{\tt pack} in the two typed modules and the actual return value of {\tt pack}.

The following table summarizes the illustration:
%% -----------------------------------------------------------------------------
\begin{center}
\begin{tabular}{l|ll}
                                 \multicolumn{3}{c}{the evaluation of} \\
\relax                  & {\tt public-data}             & {\tt secret-data} in {\tt client}, \\
{under the $\cdot$ semantics yields} & & \\ \hline
%% ----------------------------------------------------------------------------------------
\qquad {\it Natural\/}   & error, blaming              & error, blaming \\
     		   	 & \quad {\tt typed-pack-lib}  & \quad {\tt typed-pack-lib} \\
\qquad {\it Transient\/} & no error   		       & error, blaming the {\tt pack-lib}/ \\
      		  	 &    			       & \quad {\tt crypto-pack-lib} boundary \\
\qquad {\it Erasure\/}   & no error 		       & no error \\
\end{tabular}
\end{center}
%% -----------------------------------------------------------------------------

