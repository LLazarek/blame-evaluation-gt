\section{How to Sample the Experimental Space} 

The mutators for section~\ref{sec:mutate} generate 96,515,744 debugging scenarios; 
far too many to even identify the interesting ones among
them. Hence, we perform stratified uniform random sampling with two
levels of stratification to collect sufficiently many interesting
debugging scenarios for drawing statistically sound conclusions. 
The outcome of our sampling process is that we test each mode of the
rational programmer on 72192 randomly selected interesting debugging
scenarios in total spread across both benchmarks and mutators.



As outlined in section~\ref{sec:rational}, all our experimental questions
require that we answer first whether a mode of the rational programmer is
useful or not for all the interesting scenarios of a mutant $\system$.
Given the binary nature of this basic question, we can rely on random
sampling of interesting scenarios from $\lattice{\system}$ to obtain an
approximate answer.  Thus $\lattice{\system}$ becomes the first stratum
for our sampling and, given a sufficiently large sample, we can get with
high confidence either a positive answer about the usefulness of a mode of
the rational programmer or a negative answer or neither, in which case we
deduce that the mode we examine is some times useful and some times it is
not. For 95\% confidence interval and 5\% error margin, the sample  needs
to include just 96 out of the $2^N$ scenarios of $\lattice{\system}$
where $N$ is the number of components of $\system$. For lattices that have
less than 96 interesting scenarios we select all their interesting
scenarios.

The second sampling stratum is the set of mutants. After all, our mutators
generate 16,800 mutants with interesting scenarios; still far too many to
explore even after sampling the lattice of each mutant. Thus we randomly
select form the mutants of each benchmarks to obtain  the largest random
sample that keeps the experiment computationally feasible  while ensuring
that, per benchmark, the sample reflects the diversity of mutants per with
respect to the mutators that generated them.  Specifically,  we sample 80
mutants with interesting scenarios per benchmark  evenly-distributed
across all of the mutators that contribute mutants for a benchmark.


%% we use the following algorithm to select the 80 mutants evenly distributed across all of the mutators that do produce mutants of a benchmark:
%% 1. Treat each mutator as a bucket containing the mutants produced by that mutator
%% 2. Let the target-sample-size be 80
%% 3. Let the bucket-sample-size be target-sample-size/number-of-buckets
%% 4. For each bucket, do
%%    1. Randomly remove min(bucket-sample-size, mutants-in(bucket)) mutants from the bucket
%%    2. Set target-sample-size = target-sample-size - (the number of mutants removed)
%% 5. If target-sample-size is empty, done; else, go back to 3.

