%% -----------------------------------------------------------------------------

The benchmark programs for a rational-programmer experiment must 
\begin{enumerate}
   
\item vary in size, complexity and purpose;

\item be fully typed so that the choice of types is fixed; 
    
\item take advantage of the variety of typing features of a gradually
typed; and

\item have a decent number of type-able modules and a variety of module dependency graphs
 because mixing of typed and untyped code in Typed Racket takes place at the
 module level. 

\end{enumerate}

\citet{gtnffvf-jfp-2019}'s collection of Typed Racket programs for
systematically measuring the implementation's performance satisfies these
criteria. The benchmark suite consists of fully typed, correct programs, written
by a number of different authors, who have maintained and evolved these programs
over several years. The programs range widely in size, complexity, purpose,
origin and in programming style. They rely on many Typed Racket features:
occurrence typing~\citep{tf-icfp-2010}, types for mutable and immutable data
structures~\citep{hpst-sfp-2010}, types for first-class classes and
objects~\citep{tsdtf-oopsla-2012}, and types for Racket's numeric
tower~\citep{stathff-padl-12}.  Finally, all of the programs are deterministic,
so any changes in the programs' behavior between runs can be solely attributed
to the actions of the rational programmer.

Figure~\ref{table:benchmark-descriptions} describes the benchmark programs that
meet all the criteria and come with a sizeable and complex dependency graphs.
This additional filter is needed because Typed Racket demands type assignments
for entire modules. For benchmarks with less than five modules, finding errors
would almost be trivial.
