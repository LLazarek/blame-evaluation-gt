%% -----------------------------------------------------------------------------

The benchmark programs for a rational-programmer experiment must 
\begin{enumerate}
   
\item vary in size, complexity and purpose;

\item be fully typed so that the choice of types is fixed; 
    
\item take advantage of the variety of typing features of a gradually
typed; and

\item have a decent number of type-able modules and a variety of module dependency graphs
 because mixing of typed and untyped code in Typed Racket takes place at the
 module level. 

\end{enumerate}

\citet{gtnffvf-jfp-2019}'s collection of Typed Racket programs for
systematically measuring the implementation's performance satisfies these
criteria. The benchmark suite consists of fully typed, correct programs, written
by a number of different authors who had maintained and evolved these programs
over time. The programs range widely in size, complexity, purpose,
origin, and in programming style. They rely on many Typed Racket features:
occurrence typing~\citep{tf-icfp-2010}, types for mutable and immutable data
structures~\citep{hpst-sfp-2010}, types for first-class classes and
objects~\citep{tsdtf-oopsla-2012}, and types for Racket's numeric
tower~\citep{stathff-padl-12}.  Finally, all of the programs are deterministic,
so any changes in the programs' behavior between runs can be solely attributed
to the actions of the rational programmer.

Table~\ref{table:benchmark-descriptions} describes the ten benchmark programs that
meet all the criteria, and furthermore come with the largest dependency graphs.
This additional filter reflects that Typed Racket demands type assignments
for entire modules, and so finding errors in benchmarks with small dependency graphs
would almost be trivial for the rational programmer.
