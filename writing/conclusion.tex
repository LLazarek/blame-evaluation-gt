%% -----------------------------------------------------------------------------

The work of~\citet{tgpk-dls-2018} suggests that, by intuition, programmers
prefer the run-time checking of Natural over other soundness methods. But of course,
the opinion of a random set of programmers does not mean that blame
assignment adds value. Similarly, researchers and language designers have
implicitly answered this question one way or another without evidence for the
blame-strategy dimension. The experiment presented in this paper provides some
justification for the programmers' leanings and helps language creators revisit
their decisions. Of course, the design choice remains a trade-off
along several dimensions while the presented experiment sheds light on
only one of them. 

The paper does {\em not\/} address a problem in the gradually typed world that
was pointed out early on by practical researchers~\citep{incorrect-ts,
sta-nt-base-types, wmwz-ecoop-2017} and that has recently received theoretical
attention~\citep{gfd-oopsla-2019, cc-oopsla-20}: mistakes in type annotations
themselves.  Developers use gradual typing to move an untyped code base into the
typed realm, and to this end, they need typed APIs for the vast repositories of
already-existing libraries. Instead of converting the libraries themselves,
language implementors merely create facade modules that import untyped functions
and export them with type annotations, like {\tt typed-pack-lib} in
figure~\ref{fig:example}.  With those facades, the compiler can 
type-check typed modules. But, these retroactive additions of types to a library
may result from a misunderstanding of the code. \emph{Any retroactively ascribed
type may thus be a mistake itself.}

The cited evidence suggests that this scenario is quite common and largely
unadressed.  A future evaluation must develop mutators that produce incorrect
type annotations without breaking the code itself. Some preliminary work
suggests that such type mutators are even more difficult to develop than the
type-level code mutators presented here. Based on the gradual typing literature,
the Natural semantics should discover such mistakes. In contrast, the Transient
and Erasure semantics cannot help with such mistakes at all; indeed, we expect
that these latter two raise misleading exceptions or produce wrong answers
without warning.  Only additional experimental work can confirm or reject these
conjectures.



